# Bootstrap Flux — Design

## Goal

Establish GitOps as the deployment model for all subsequent roadmap steps. This means: push the repo to GitHub, add CI, and bootstrap Flux CD so that every future change deploys through git commits.

## Prerequisites

### GitHub repository

Create a public repo named `cloudlab`. Push the existing local repo as-is.

**Branch protection on `main`:**

- Require pull request reviews before merging
- Require status checks to pass
- Block force pushes
- Include administrators

**Security verification before the first push:**

- Run `gitleaks detect` against the full history
- Confirm `.gitignore` covers `terraform.tfstate*`, `.age-key.txt`, and decrypted configs
- Confirm SOPS-encrypted files contain only ciphertext

What is safe to expose publicly:

- Terraform configuration (resource definitions, provider setup)
- SOPS-encrypted files (ciphertext without the age key is useless)
- Network topology (RFC1918 private addresses, unreachable from the internet)
- Flux manifests and HelmRelease definitions

What must never be committed:

- `.age-key.txt` (already gitignored)
- `terraform.tfstate` (already gitignored)
- Decrypted kubeconfig/talosconfig (already gitignored)
- Plaintext API tokens or passwords

### Flux authentication

`flux bootstrap github` creates a read-only SSH deploy key scoped to this single repo. The process requires a GitHub personal access token (PAT) at bootstrap time only — Flux uses the PAT to register the deploy key, then discards it. The PAT never enters the cluster.

Use a fine-grained PAT scoped to the `cloudlab` repository only, with a short expiration (1 day). Required permissions: Administration (read/write) to create the deploy key, Contents (read/write) to push the flux-system manifests, and Metadata (read-only, auto-granted).

## Changes

### 1. Directory structure (kubernetes/)

`flux bootstrap github` with `--path=kubernetes/` creates the `flux-system/` directory and pushes it to the repo. We then add `infrastructure/` and `apps/` directories with Flux Kustomizations.

```
kubernetes/
  flux-system/              # Auto-generated by flux bootstrap
    gotk-components.yaml      # Flux controller manifests
    gotk-sync.yaml            # Self-referencing GitRepository + Kustomization
    kustomization.yaml        # Kustomize entry point
  infrastructure/           # Cluster services (ingress, cert-manager, storage, etc.)
    kustomization.yaml
  apps/                     # Workloads (empty until step 15)
    kustomization.yaml
```

Flux watches only the `kubernetes/` path. Terraform changes do not trigger reconciliation.

### 2. Kustomization hierarchy (kubernetes/)

Two child Kustomizations enforce dependency ordering:

```yaml
# kubernetes/flux-system/infrastructure.yaml
apiVersion: kustomize.toolkit.fluxcd.io/v1
kind: Kustomization
metadata:
  name: infrastructure
  namespace: flux-system
spec:
  interval: 10m
  retryInterval: 2m
  sourceRef:
    kind: GitRepository
    name: flux-system
  path: ./kubernetes/infrastructure
  prune: true
  wait: true
  timeout: 5m
  dependsOn:
    - name: flux-system
```

```yaml
# kubernetes/flux-system/apps.yaml
apiVersion: kustomize.toolkit.fluxcd.io/v1
kind: Kustomization
metadata:
  name: apps
  namespace: flux-system
spec:
  interval: 10m
  retryInterval: 2m
  sourceRef:
    kind: GitRepository
    name: flux-system
  path: ./kubernetes/apps
  prune: true
  wait: true
  timeout: 5m
  dependsOn:
    - name: infrastructure
```

The dependency chain: `flux-system` → `infrastructure` → `apps`. Infrastructure services must be healthy before any apps deploy.

Each infrastructure component gets its own subdirectory with a namespace, HelmRepository, and HelmRelease. Flux picks up new subdirectories on the next reconciliation cycle (default 10 minutes, or forced with `flux reconcile`).

### 3. Helm chart management

All Helm-based tools on the roadmap (ingress controller, cert-manager, Prometheus, Grafana, Loki, etc.) deploy as Flux HelmRelease CRDs. Each HelmRelease declares a HelmRepository source and inline values. Flux handles install, upgrade, rollback, and drift detection.

This pairs with Renovate (step 15), which auto-opens PRs when chart versions update.

### 4. Validation strategy (lefthook.yml, .mise.toml, .github/workflows/)

Three execution contexts, layered for speed and thoroughness:

| Context | Runs when | Speed | Scope |
|---------|-----------|-------|-------|
| Lefthook (pre-commit) | Every commit | Fast | Staged files only |
| `mise run check` | On demand | Thorough | Whole project |
| GitHub Actions | Every PR | Thorough | Whole project |

**Lefthook (fast, staged files only):**

- `terraform fmt -check` on `*.tf`
- `kustomize build` on `kubernetes/**/*.yaml`
- `gitleaks` on staged files

**`mise run check` (thorough, whole project):**

- `terraform fmt -check`
- `terraform validate`
- `tflint`
- `kustomize build kubernetes/`
- `kubeconform` (full schema validation on built manifests)
- `gitleaks git`

**GitHub Actions (on PRs, gates merge):**

- Runs `mise run check` via `jdx/mise-action` (same tool versions from `.mise.toml`)
- Gitleaks on full PR diff
- Required status check for merge

`mise run check` is the single source of truth. Lefthook runs a fast subset. GitHub Actions runs the full thing. No Terraform `plan` in CI — that would require cluster credentials in a public repo.

### 5. Tool versions (.mise.toml)

Add to `.mise.toml`:

- `kubeconform` — Kubernetes manifest schema validation
- `flux2` — Flux CLI (`flux bootstrap`, `flux check`, `flux reconcile`)

### 6. Roadmap updates (README.md)

Insert Kyverno, Gitea/Forgejo, Renovate, and Infisical into the roadmap. Remove External-Secrets Operator (Infisical replaces 1Password). Renumber all steps.

**Full updated roadmap:**

#### Phase 1: Foundation

1. ~~SecureBoot + disk encryption~~
2. **Bootstrap Flux** — GitHub repo, CI, GitOps foundation
3. SOPS + Flux — Decrypt SOPS-encrypted secrets in-cluster via kustomize-controller
4. NFS storage provisioner — Dynamic PersistentVolumes backed by Synology NAS
5. Ingress controller — Route external HTTP/HTTPS traffic to cluster services
6. cert-manager — Automated TLS certificates via Let's Encrypt
7. Internal DNS — Resolve friendly service names to the ingress IP
8. Monitoring — Prometheus + Grafana for metrics, dashboards, and cluster health

#### Phase 2: Operational Excellence

9. Log aggregation — Loki + Promtail for centralized container logs
10. Alerting — Alertmanager with notifications to Pushover, Discord, or similar
11. Kyverno — Image signature verification first, general policies later
12. etcd backups — Periodic `talosctl etcd snapshot` to Synology NAS (Proxmox VM backups cover the gap until here)
13. Authentication gateway — Single sign-on and 2FA in front of all services
14. Gitea/Forgejo — First self-hosted app; migrate Flux source from GitHub
15. Renovate — Automated dependency updates (against Gitea)
16. Infisical — Self-hosted secrets management; begin migrating from SOPS

#### Phase 3: Expand and Harden

17. Remote access — Tailscale for secure access from outside the home network
18. Network policies — Cilium policies to isolate namespaces and restrict traffic
19. Multi-node expansion — Add worker node(s); refactor Terraform with `for_each`
20. Automated cluster upgrades — Formalize TalosOS and Kubernetes upgrade workflow
21. Remote Terraform state — S3-compatible backend on Synology for state locking

#### Phase 4: Advanced Platform

22. Hubble observability — Cilium's service map and flow visibility via eBPF
23. PersistentVolume backups — Volsync for scheduled PVC replication to NAS
24. Cluster dashboard — Headlamp for visual cluster inspection behind auth

#### Phase 5: Platform Maturity

25. Gateway API migration — Move from Ingress resources to HTTPRoute/Gateway
26. Image pull-through cache — Spegel for peer-to-peer registry mirroring on-cluster
27. Descheduler — Evict pods that violate scheduling constraints over time

#### Phase 6: Operational Confidence

28. Chaos testing — Break things on purpose; verify alerts fire and recovery works
29. Resource quotas — Per-namespace CPU/memory limits to prevent resource starvation
30. GitOps repo refactor — Kustomize base/overlays structure for multi-cluster readiness

**Updated decisions table:**

| Decision | Step | Options |
|----------|------|---------|
| Flux repo structure | 2 | ~~Monorepo~~ (chosen) vs separate GitOps repo |
| NFS provisioner | 4 | democratic-csi vs nfs-subdir-external-provisioner |
| Ingress approach | 5 | ingress-nginx, Cilium ingress, or Gateway API directly |
| Service domain | 7 | `*.home.arpa`, `*.cloudlab.local`, or a real domain with split-horizon DNS |
| Auth architecture | 13 | Authelia vs Authentik |
| VCS platform | 14 | Gitea vs Forgejo |
| Secrets manager | 16 | Infisical self-hosted vs other |

## Bootstrap Sequence

**Push to GitHub:**

1. Run `gitleaks detect` to verify no secrets in history
2. Create public `cloudlab` repo on GitHub (no generated files)
3. Push existing repo
4. Configure branch protection on `main`

**Add CI and validation tooling:**

5. Add `kubeconform` and `flux2` to `.mise.toml`
6. Expand `mise run check` with Kubernetes validation tasks
7. Add Kubernetes manifest checks to `lefthook.yml`
8. Add `.github/workflows/check.yml` (runs `mise run check` on PRs)
9. Commit and push

**Bootstrap Flux:**

10. Create a short-lived GitHub PAT (`repo` scope, 1-day expiry)
11. Run: `flux bootstrap github --owner=<you> --repository=cloudlab --path=kubernetes/ --personal`
12. Flux creates `kubernetes/flux-system/`, pushes to the repo, and installs controllers
13. Delete the PAT
14. Verify: `flux check` and `kubectl get kustomizations -A`

**Post-bootstrap:**

15. Add `kubernetes/infrastructure/` Kustomization (depends on flux-system)
16. Add `kubernetes/apps/` Kustomization (depends on infrastructure)
17. Commit and push — Flux reconciles automatically

## Out of Scope

- **Ingress controller selection** — decided at step 5
- **SOPS integration with Flux** — step 3
- **NFS storage** — step 4
- **Kyverno policies** — step 11
- **Gitea/Forgejo deployment** — step 14
- **Infisical deployment** — step 16
- **Terraform `plan` in CI** — requires cluster credentials; unsuitable for a public repo
